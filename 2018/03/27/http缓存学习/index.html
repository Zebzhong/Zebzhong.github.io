<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>http缓存学习 | Zebzhong的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="缓存分为三类： 1.浏览器缓存我相信只要你经常使用某个浏览器🌎(Chrome,Firefox,IE等)，肯定知道这些浏览器在设置里面都是有个清除缓存功能，这个功能存在的作用就是删除存储在你本地磁盘上资源副本，也就是清除缓存。缓存存在的意义就是当用户点击back按钮或是再次去访问某个页面的时候能够更快的响应。尤其是在多页应用的网站中，如果你在多个页面使用了一张相同的图片，那么缓存这张图片就变得特别">
<meta property="og:type" content="article">
<meta property="og:title" content="http缓存学习">
<meta property="og:url" content="http://yoursite.com/2018/03/27/http缓存学习/index.html">
<meta property="og:site_name" content="Zebzhong的博客">
<meta property="og:description" content="缓存分为三类： 1.浏览器缓存我相信只要你经常使用某个浏览器🌎(Chrome,Firefox,IE等)，肯定知道这些浏览器在设置里面都是有个清除缓存功能，这个功能存在的作用就是删除存储在你本地磁盘上资源副本，也就是清除缓存。缓存存在的意义就是当用户点击back按钮或是再次去访问某个页面的时候能够更快的响应。尤其是在多页应用的网站中，如果你在多个页面使用了一张相同的图片，那么缓存这张图片就变得特别">
<meta property="og:locale" content="cn">
<meta property="og:updated_time" content="2018-03-27T03:33:30.016Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="http缓存学习">
<meta name="twitter:description" content="缓存分为三类： 1.浏览器缓存我相信只要你经常使用某个浏览器🌎(Chrome,Firefox,IE等)，肯定知道这些浏览器在设置里面都是有个清除缓存功能，这个功能存在的作用就是删除存储在你本地磁盘上资源副本，也就是清除缓存。缓存存在的意义就是当用户点击back按钮或是再次去访问某个页面的时候能够更快的响应。尤其是在多页应用的网站中，如果你在多个页面使用了一张相同的图片，那么缓存这张图片就变得特别">
  
    <link rel="alternate" href="/atom.xml" title="Zebzhong的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Zebzhong的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-http缓存学习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/27/http缓存学习/" class="article-date">
  <time datetime="2018-03-27T01:46:08.000Z" itemprop="datePublished">2018-03-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      http缓存学习
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>缓存分为三类：</p>
<h2 id="1-浏览器缓存"><a href="#1-浏览器缓存" class="headerlink" title="1.浏览器缓存"></a>1.浏览器缓存</h2><p>我相信只要你经常使用某个浏览器🌎(Chrome,Firefox,IE等)，肯定知道这些浏览器在设置里面都是有个清除缓存功能，这个功能存在的作用就是删除存储在你本地磁盘上资源副本，也就是清除缓存。<br>缓存存在的意义就是当用户点击back按钮或是再次去访问某个页面的时候能够更快的响应。尤其是在多页应用的网站中，如果你在多个页面使用了一张相同的图片，那么缓存这张图片就变得特别的有用。<br>微观上分为三类：</p>
<h2 id="2-代理服务器缓存"><a href="#2-代理服务器缓存" class="headerlink" title="2. 代理服务器缓存"></a>2. 代理服务器缓存</h2><p>代理服务器缓存原理和浏览器端类似，但规模要大得多，因为是为成千上万的用户提供缓存机制，大公司和大型的ISP提供商通常会将它们设立在防火墙上或是作为一个独立的设备来运营。(下文如果没有特殊说明,所有提到的缓存服务器都是指代理服务器。)<br>由于缓存服务器不是客户端或是源服务器的一部分，它们存在于网络中，请求路由必须经过它们才会生效，所以实际上你可以去手动设置浏览器的代理，或是通过一个中间服务器来进行转发，这样用户自然就察觉不到代理服务器的存在了。🤥<br>代理服务器缓存就是一个共享缓存，不只为一个用户服务，经常为大量用户使用，因此在减少相应时间和带宽使用方面很有效：因为同一个缓存可能会被重用多次。</p>
<h2 id="3-网关缓存"><a href="#3-网关缓存" class="headerlink" title="3. 网关缓存"></a>3. 网关缓存</h2><p>也被称为代理缓存或反向代理缓存，网关也是一个中间服务器，网关缓存一般是网站管理员自己部署，从让网站拥有更好的性能。🙂<br>CDNS(网络内容分发商)分布网关缓存到整个（或部分）互联网上，并出售缓存服务给需要的网站，比如国内的七牛云、又拍云都有这种服务。</p>
<h2 id="4-数据库缓存"><a href="#4-数据库缓存" class="headerlink" title="4. 数据库缓存"></a>4. 数据库缓存</h2><p>数据库缓存是指当我们的应用极其复杂，表自然也很繁杂，我们必须进行频繁的进行数据库查询，这样可能导致数据库不堪重负，一个好的办法就是将查询后的数据放到内存中，下一次查询直接从内存中取就好了。关于数据库缓存本篇不会展开。🙃<br>浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。<br>那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢？响应头！响应头！响应头！重要的事情说三遍。✌️<br>我们看🌰：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Age:23146</span><br><span class="line">Cache-Control:max-age=2592000</span><br><span class="line">Date:Tue, 28 Nov 2017 12:26:41 GMT</span><br><span class="line">ETag:W/&quot;5a1cf09a-63c6&quot;</span><br><span class="line">Expires:Thu, 28 Dec 2017 05:27:45 GMT</span><br><span class="line">Last-Modified:Tue, 28 Nov 2017 05:14:02 GMT</span><br><span class="line">Vary:Accept-Encoding</span><br></pre></td></tr></table></figure></p>
<h3 id="1-强缓存阶段"><a href="#1-强缓存阶段" class="headerlink" title="1. 强缓存阶段"></a>1. 强缓存阶段</h3><p>以上请求头来自百度首页某个CSS文件的响应头。我去除了一些和缓存无关的字段，只保留了以上部分。我们来分析下，Expires是HTTP/1.0中的定义缓存的字段，它规定了缓存过期的一个绝对时间。Cache-Control:max-age=2592000是HTTP/1.1定义的关于缓存的字段，它规定了缓存过期的一个相对时间。优先级上当然是版本高的优先了，max-age &gt; Expires。<br>这就是强缓存阶段，当浏览器再次试图访问这个CSS文件，发现有这个文件的缓存，那么就判断根据上一次的响应判断是否过期，如果没过期，使用缓存。加载文件，OVER！✌️<br>Firefox浏览器表现为一个灰色的200状态码。<br>Chrome浏览器状态码表现为:<br>200 (from disk cache)或是200 OK (from memory cache)<br><strong>多说一点：</strong>关于缓存是从磁盘中获取还是从内存中获取，查找了很多资料，得出了一个较为可信的结论：Chrome会根据本地内存的使用率来决定缓存存放在哪，如果内存使用率很高，放在磁盘里面，内存的使用率很高会暂时放在内存里面。这就可以比较合理的解释了为什么同一个资源有时是from memory cache有时是from disk cache的问题了。<br>那么当这个CSS文件过期了怎么办?ETag和Last-Modified就该闪亮登场了。<br>先说Last-Modified，这个字段是文件最后一次修改的时间；<br>ETag呢？ETag是对文件的一个标记，嗯，可以这么说，具体生成方式HTTP并没有给出一个明确的方式，所以理论上只要不会重复生成方式无所谓，比如对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号。</p>
<p>1）当ctrl+f5强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；</p>
<p>2）当f5刷新网页时，跳过强缓存，但是会检查协商缓存；</p>
<h3 id="2-协商缓存阶段"><a href="#2-协商缓存阶段" class="headerlink" title="2. 协商缓存阶段"></a>2. 协商缓存阶段</h3><p>利用这两个字段浏览器可以进入协商缓存阶段，当浏览器再次试图访问这个CSS文件，发现缓存过期，于是会在本次请求的请求头里携带If-Moified-Since和If-None-Match这两个字段，服务器通过这两个字段来判断资源是否有修改，如果有修改则返回状态码200和新的内容，如果没有修改返回状态码304，浏览器收到200状态码，该咋处理就咋处理(相当于首次访问这个文件了)，发现返回304，于是知道了本地缓存虽然过期但仍然可以用，于是加载本地缓存。然后根据新的返回的响应头来设置缓存。(这一步有所差异，发现不同浏览器的处理是不同的，chrome会为304设置缓存，firefox则不会)😑<br>具体两个字段携带的内容如下(分别和上面的Last-Modified、ETag携带的值对应)：<br>If-Moified-Since: Tue, 28 Nov 2017 05:14:02 GMT<br>If-None-Match: W/“5a1cf09a-63c6”<br>到这协商缓存结束。</p>
<h3 id="3-启发式缓存阶段"><a href="#3-启发式缓存阶段" class="headerlink" title="3. 启发式缓存阶段"></a>3. 启发式缓存阶段</h3><p>我们把上面的响应头改下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Age:23146</span><br><span class="line">Cache-Control: public</span><br><span class="line">Date:Tue, 28 Nov 2017 12:26:41 GMT</span><br><span class="line">Last-Modified:Tue, 28 Nov 2017 05:14:02 GMT</span><br><span class="line">Vary:Accept-Encoding</span><br></pre></td></tr></table></figure></p>
<p>发现没？浏览器用来确定缓存过期时间的字段一个都没有！那该怎么办？有人可能会说下次请求直接进入协商缓存阶段，携带If-Moified-Since呗，不是的，浏览器还有个启发式缓存阶段😎<br>根据响应头中2个时间字段 Date 和 Last-Modified 之间的时间差值，取其值的10%作为缓存时间周期。<br>这就是启发式缓存阶段。这个阶段很容让人忽视，但实际上每时每刻都在发挥着作用。所以在今后的开发过程中如果遇到那种默认缓存的坑，不要叫嚣，不要生气，浏览器只是在遵循启发式缓存协议而已。<br>HTTP中和缓存相关的首部字段<br>HTTP报文是什么呢？就是HTTP报文，这是一个概念，主要由以下两部分构成：<br>首部(header)：包含了很多字段，比如：cookie、缓存、报文大小、报文格式等等）；<br>主体(body)：HTTP请求真正要传输的部分，比如：一个HTML文档，一个js文件；<br>以上我们知道浏览器对于缓存的处理过程，也简单的提到了几个相关的字段。🤧接下来我们具体看下这几个字段：</p>
<ol>
<li><p>通用首部字段<br>字段名称 说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control 控制缓存具体的行为</span><br><span class="line">Pragma HTTP1.0时的遗留字段，当值为&quot;no-cache&quot;时强制验证缓存</span><br><span class="line">Date 创建报文的日期时间(启发式缓存阶段会用到这个字段)</span><br></pre></td></tr></table></figure>
</li>
<li><p>响应首部字段<br>字段名称 说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ETag 服务器生成资源的唯一标识</span><br><span class="line">Vary 代理服务器缓存的管理信息</span><br><span class="line">Age 资源在缓存代理中存贮的时长(取决于max-age和s-maxage的大小)</span><br></pre></td></tr></table></figure>
</li>
<li><p>请求首部字段<br>字段名称 说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">If-Match 条件请求，携带上一次请求中资源的ETag，服务器根据这个字段判断文件是否有新的修改</span><br><span class="line">If-None-Match 和If-Match作用相反，服务器根据这个字段判断文件是否有新的修改</span><br><span class="line">If-Modified-Since 比较资源前后两次访问最后的修改时间是否一致</span><br><span class="line">If-Unmodified-Since 比较资源前后两次访问最后的修改时间是否一致</span><br></pre></td></tr></table></figure>
</li>
<li><p>实体首部字段<br>字段名称 说明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Expires 告知客户端资源缓存失效的绝对时间</span><br><span class="line">Last-Modified 资源最后一次修改的时间</span><br><span class="line">🦅浏览器缓存控制</span><br><span class="line">HTTP/1.1一共规范了47种首部字段，而和缓存相关的就有以上12个之多。接下来的两个小节会一个一个介绍给大家。🤓</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="1-Cache-Control"><a href="#1-Cache-Control" class="headerlink" title="1. Cache-Control"></a>1. Cache-Control</h4><p>通过cache-control的指令可以控制告诉客户端或是服务器如何处理缓存。这也是11个字段中指令最多的一个，我们先来看看请求指令：<br>指令 参数 说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">no-cache 无 强制源服务器再次验证</span><br><span class="line">no-store 无 不缓存请求或是响应的任何内容</span><br><span class="line">max-age=[秒] 缓存时长，单位是秒 缓存的时长，也是响应的最大的Age值</span><br><span class="line">min-fresh=[秒] 必需 期望在指定时间内响应仍然有效</span><br><span class="line">no-transform 无 代理不可更改媒体类型</span><br><span class="line">only-if-cached 无 从缓存获取</span><br><span class="line">cache-extension - 新的指令标记(token)</span><br><span class="line">响应指令：</span><br><span class="line">指令 参数 说明</span><br><span class="line">public 无 任意一方都能缓存该资源(客户端、代理服务器等)</span><br><span class="line">private 可省略 只能特定用户缓存该资源</span><br><span class="line">no-cache 可省略 缓存前必须先确认其有效性</span><br><span class="line">no-store 无 不缓存请求或响应的任何内容</span><br><span class="line">no-transform 无 代理不可更改媒体类型</span><br><span class="line">must-revalidate 无 可缓存但必须再向源服务器进确认</span><br><span class="line">proxy-revalidate 无 要求中间缓存服务器对缓存的响应有效性再进行确认</span><br><span class="line">max-age=[秒] 缓存时长，单位是秒 缓存的时长，也是响应的最大的Age值</span><br><span class="line">s-maxage=[秒] 必需 公共缓存服务器响应的最大Age值</span><br><span class="line">cache-extension - 新指令标记(token</span><br><span class="line">请注意no-cache指令很多人误以为是不缓存，这是不准确的，no-cache的意思是可以缓存，但每次用应该去想服务器验证缓存是否可用。no-store才是不缓存内容。另外部分指令也可以组合使用，比如：</span><br><span class="line">Cache-Control: max-age=100, must-revalidate, public</span><br><span class="line">上面指令的意思是缓存的有效时间为100秒，之后访问需要向源服务器发送请求验证，此缓存可被代理服务器和客户端缓存。</span><br></pre></td></tr></table></figure></p>
<h4 id="2-Pragma"><a href="#2-Pragma" class="headerlink" title="2. Pragma"></a>2. Pragma</h4><p>这是HTTP/1.0里面的一个字段，但优先级很高，测试发现，Chrome和Firefox中Pragma的优先级高于Cache-Control和Expires，为了向下兼容，这个字段依然发挥着它的作用。🤔一般可能我们会这么用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>Pragma属于通用首部字段，在客户端上使用时，常规要求我们往html上加上上面这段meta元标签（而且可能还得做些hack放到body后面去。<br>事实上这种禁用缓存的形式用处很有限：<br>仅有IE才能识别这段meta标签含义，其它主流浏览器仅能识别Cache-Control: no-store的meta标签(见出处)<br>在IE中识别到该meta标签含义，并不一定会在请求字段加上Pragma，但的确会让当前页面每次都发新请求(仅限页面，页面上的资源则不受影响)。——浅谈浏览器http的缓存机制<br>读者可以自行拷贝后面模拟服务端决策的代码进行测试。<br>服务端响应添加’Pragma’: ‘no-cache’，浏览器表现行为和强制刷新类似。</p>
<h4 id="3-Expires"><a href="#3-Expires" class="headerlink" title="3. Expires"></a>3. Expires</h4><p>这又是一个HTTP/1.0的字段，上面也说过了定义的是缓存到期的绝对时间。<br>同样，我们也可以在html文件里直接使用:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=&quot;expires&quot; content=&quot;Thu, 30 Nov 2017 11:17:26 GMT&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果设置的是已经过去的时间会怎样呢？YES！！！则刷新页面会重新发送请求。<br><strong>Pragma禁用缓存，如果又给Expires定义一个还未到期的时间，那么Pragma字段的优先级会更高。</strong>🤖<br>🤖Expires有一个很大的弊端，就是它返回的是服务器的时间，但判断的时候用的却是客户端的时间，这就导致Expires很被动，因为用户有可能改变客户端的时间，导致缓存时间判断出错，这也是引入Cache-Control:max-age指令的原因之一。</p>
<h4 id="4-Last-Midified"><a href="#4-Last-Midified" class="headerlink" title="4. Last-Midified"></a>4. Last-Midified</h4><p>接下来这几个字段都是校验字段，或者说是在协商缓存阶段发挥作用的字段。第一个就是Last-modified，这个字段不光协商缓存起作用，在启发式缓存阶段同样起到至关重要的作用。<br>在浏览器第一次请求某一个URL时，服务器端的返回状态码会是200，响应的实体内容是客户端请求的资源，同时有一个Last-Modified的属性标记此文件在服务器端最后被修改的时间。like this:<br>Last-Modified : Fri , 12 May 2006 18:53:33 GMT<br>If-Modified-Since<br>当浏览器第二次请求这个URL的时候，根据HTTP协议规定，浏览器会把第一次Last-Modified的值存储在If-Modified-Since里面发送给服务端来验证资源有没有修改。like this:<br>If-Modified-Since : Fri , 12 May 2006 18:53:33 GMT<br>服务端通过If-Modified-Since字段来判断在这两次访问期间资源有没有被修改过，从而决定是否返回完整的资源。如果有修改正常返回资源，状态码200，如果没有修改只返回响应头，状态码304，告知浏览器资源的本地缓存还可用。<br>用途：<br>If-Unmodified-Since<br>这个字段字面意思和If-Modified-Since相反，但处理方式并不是相反的。如果文件在两次访问期间没有被修改则返回200和资源，如果文件修改了则返回状态码412(预处理错误)。<br>用途：<br>与含有 If-Range消息头的范围请求搭配使用，实现断点续传的功能，即如果资源没修改继续下载，如果资源修改了，续传的意义就没有了。<br>POST、PUT请求中，优化并发控制，即当多用户编辑用一份文档的时候，如果服务器的资源已经被修改，那么在对其作出编辑会被拒绝提交。<br>😈Last-Modified有几个缺点：没法准确的判断资源是否真的修改了，比如某个文件在1秒内频繁更改了多次，根据Last-Modified的时间(单位是秒)是判断不出来的，再比如，某个资源只是修改了，但实际内容并没有发生变化，Last-Modified也无法判断出来，因此在HTTP/1.1中还推出了ETag这个字段👇</p>
<h4 id="5-ETag"><a href="#5-ETag" class="headerlink" title="5. ETag"></a>5. ETag</h4><p>服务器可以通过某种自定的算法对资源生成一个唯一的标识(比如md5标识)，然后在浏览器第一次请求某一个URL时把这个标识放到响应头传到客户端。服务器端的返回状态会是200。<br>ETag: abc-123456<br>ETag的值有可能包含一个 W/ 前缀，来提示应该采用弱比较算法（这个是画蛇添足，因为 If-None-Match 用且仅用这一算法）。🙄<br>If-None-Match<br>If-None-Match和If-Modified-Since同时存在的时候If-None-Match优先级更高。<br>当浏览器第二次请求这个URL的时候，根据HTTP协议规定，浏览器回把第一次ETag的值存储在If-None-Match里面发送给服务端来验证资源有没有修改。like this:<br>If-None-Match: abc-123456<br>Get请求中，当且仅当服务器上没有任何资源的ETag属性值与这个首部中列出的相匹配的时候，服务器端会才返回所请求的资源，响应码为200。如果没有资源的ETag值相匹配，那么返回304状态码。<br>POST、PUT等请求改变文件的请求，如果没有资源的ETag值相匹配，那么返回412状态码。<br>If-Match<br>在请求方法为 GET) 和 HEAD的情况下，服务器仅在请求的资源满足此首部列出的 ETag 之一时才会返回资源。而对于 PUT或其他非安全方法来说，只有在满足条件的情况下才可以将资源上传。<br>用途：<br>For GET和 HEAD 方法，搭配 Range首部使用，可以用来保证新请求的范围与之前请求的范围是对同一份资源的请求。如果 ETag 无法匹配，那么需要返回 416（范围请求无法满足) 响应。<br>对于其他方法来说，尤其是 PUT, If-Match 首部可以用来避免更新丢失问题。它可以用来检测用户想要上传的不会覆盖获取原始资源之后做出的更新。如果请求的条件不满足，那么需要返回412(预处理错误) 响应。<br>当然和Last-Modified相比，ETag也有自己的缺点，比如由于需要对资源进行生成标识，性能方面就势必有所牺牲。😕<br>关于强校验和弱校验：<br>ETag 1 ETag 2 Strong Comparison Weak Comparison<br>W/“1” W/“1” no match match<br>W/“1” W/“2” no match no match<br>W/“1” “1” no match match<br>“1” “1” match match<br>🐝服务端缓存控制<br>当Expires和Cache-Control:max-age=xxx同时存在的时候取决于缓存服务器应用的HTTP版本。应用HTTP/1.1版本的服务器会优先处理max-age，忽略Expires，而应用HTTP/1.0版本的缓存服务器则会优先处理Expires而忽略max-age。接下来看下和缓存服务器相关的两个字段。</p>
<h4 id="6-Vary"><a href="#6-Vary" class="headerlink" title="6. Vary"></a>6. Vary</h4><p>Vary用来做什么的呢？试想这么一个场景：在某个网页中网站提供给移动端的内容是不同的，怎么让缓存服务器区分移动端和PC端呢？不知道你是否注意，浏览器在每次请求都会携带UA字段来表明来源，所以我们可以利用User-Agent字段来区分不同的客户端，用法如下：<br>Vary: User-Agent<br>再比如，源服务器启用了gzip压缩，但用户使用了比较旧的浏览器，不支持压缩，缓存服务器如何返回？就可以这么设定：<br>Vary: Accept-Encoding<br>当然，也可以这么用：<br>Vary: User-Agent, Accept-Encoding<br>这意味着缓存服务器会以 User-Agent 和 Accept-Encoding 两个请求首部字段来区分缓存版本。根据请求头里的这两个字段来决定返回给客户端什么内容。</p>
<h4 id="7-Age"><a href="#7-Age" class="headerlink" title="7. Age"></a>7. Age</h4><p>这个字段说的是资源在缓存服务器存在的时长，前面也说了Cache-Control: max-age=[秒]就是Age的最大值。<br>这个字段存在的意义是什么呢？用来区分请求的资源来自源服务器还是缓存服务器的缓存的。<br>🤧但得结合另一个字段来进行判断，就是Date，Date是报文创建的时间。<br>Date<br>如果按F5频繁刷新发现响应里的Date没有改变，就说明命中了缓存服务器的缓存以下面的一个响应为🍐：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: bytes</span><br><span class="line">Age: 1016859</span><br><span class="line">Cache-Control: max-age=2592000</span><br><span class="line">Content-Length: 14119</span><br><span class="line">Content-Type: image/png</span><br><span class="line">Date: Fri, 01 Dec 2017 12:27:25 GMT</span><br><span class="line">ETag: &quot;5912bfd0-3727&quot;</span><br><span class="line">Expires: Tue, 19 Dec 2017 17:59:46 GMT</span><br><span class="line">Last-Modified: Wed, 10 May 2017 07:22:56 GMT</span><br><span class="line">Ohc-Response-Time: 1 0 0 0 0 0</span><br><span class="line">Server: bfe/1.0.8.13-sslpool-patch</span><br></pre></td></tr></table></figure></p>
<p>如上图来自百度首页某个图片的响应字段。我们可以看到Age=1016859，说明这个资源已经在缓存服务器存在了1016859秒。如果文件被修改或替换，Age会重新由0开始累计。<br>Age消息头的值通常接近于0。表示此消息对象刚刚从原始服务器获取不久；其他的值则是表示代理服务器当前的系统时间与此应答消息中的通用消息头 Date的值之差。<br>上面这个结论归结为一个等式就是：<br>静态资源Age + 静态资源Date = 原服务端Date<br>🐲用户操作行为对缓存的影响<br>搜索了很久有没有关于这方面的权威总结，最后竟然在百度百科找到了也是很惊讶，我自己加了一条用户强制刷新操作浏览器的反应。强制刷新，window下是Ctrl+F5,mac下就是command+shift+R操作了。<br>操作 说明<br>打开新窗口 如果指定cache-control的值为private、no-cache、must-revalidate,那么打开新窗口访问时都会重新访问服务器。而如果指定了max-age值,那么在此值内的时间里就不会重新访问服务器,例如：Cache-control: max-age=5 表示当访问此网页后的5秒内不会去再次访问服务器.<br>在地址栏回车 如果值为private或must-revalidate,则只有第一次访问时会访问服务器,以后就不再访问。如果值为no-cache,那么每次都会访问。如果值为max-age,则在过期之前不会重复访问。<br>按后退按扭 如果值为private、must-revalidate、max-age,则不会重访问,而如果为no-cache,则每次都重复访问.<br>按刷新按扭 无论为何值,都会重复访问.（可能返回状态码：200、304，这个不同浏览器处理是不一样的，FireFox正常，Chrome则会启用缓存(200 from cache)）<br>按强制刷新按钮 当做首次进入重新请求(返回状态码200)<br>来自百度百科<br>如果想在浏览器点击“刷新”按钮的时候不让浏览器去发新的验证请求呢？办法找到一个，知乎上面一个回答，在页面加载完毕后通过脚本动态地添加资源：<br>$(window).load(function() {<br>      var bg=’<a href="http://img.infinitynewtab.com/wallpaper/100.jpg&#39;" target="_blank" rel="noopener">http://img.infinitynewtab.com/wallpaper/100.jpg&#39;</a>;<br>      setTimeout(function() {<br>        $(‘#bgOut’).css(‘background-image’, ‘url(‘+bg+’)’);<br>      },0);<br>});<br>来自知乎<br>🐩HTML5的缓存<br>这部分准备的说应该叫离线存储。现在比较普遍用的是Appcache，但Appcache已经从web标准移除了，在可预见的未来里，ServiceWorker可能会是一个比较适合的解决方案。</p>
<ol>
<li>Appcache<br>这是HTML5的一个新特性，通过离线存储达到用户在没有网络连接的情况下也能访问页面的功能。离线状态下即使用户点击刷新都能正常加载文档。<br>使用方法如下，在HTML文件中引入appcache文件:<br>&lt;!DOCTYPE html&gt;<br><html manifest="manifest.appcache"><br><head><br><meta charset="UTF-8"><br><title>***</title><br></head><br><body><br><div id="root"></div><br></body><br></html><br>🤠web 应用中的 manifest 特性可以指定为缓存清单文件的相对路径或一个绝对 URL(绝对 URL 必须与应用同源)。缓存清单文件可以使用任意扩展名，但传输它的 MIME 类型必须为 text/cache-manifest。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/03/27/http缓存学习/" data-id="cjf9037x90001fsvoryhm64nn" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2018/03/06/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/03/27/http缓存学习/">http缓存学习</a>
          </li>
        
          <li>
            <a href="/2018/03/06/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Zebzhong<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>